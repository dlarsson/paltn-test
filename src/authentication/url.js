import urlRelative from 'url-relative';
import passport from 'passport';
import strategy from 'passport-strategy';
import crypto from '../lib/crypto';

/* eslint no-underscore-dangle: "off" */

function roundedTime(roundMs) {
  const ct = new Date();
  const nt = ct - ct % roundMs;
  return new Date(nt);
}

const ROUNDED_TO = 10 * 60 * 1000; // minutes
const EXPIRY_TIME = 5 * 60 * 60 * 1000; // hours
const DELIMITER = ':::';

function serializeUserAsPromised(user, req) {
  return new Promise((resolve, reject) => {
    passport.serializeUser(user, req, (err, data) => {
      if (err !== null) {
        return reject(err);
      }
      return resolve(data);
    });
  });
}

const noop = () => undefined;

const EXPIRED = 'URL.expired';

/**
 * Authentication through encrypted URL.
 *
 * This authentication strategy allows encoding authentication information
 * inside the URL itself. This is useful for browser apps which want to
 * provide clickable URLs for downloading e.g. files. The URL contains
 * the target URL, the user to authenticate as, and an expiry date.
 *
 * The original URL generated by the server, on behalf of a user authenticated
 * through some other means. The user is serialized using the passport method
 * of serializing users (i.e. by defining passport.serializeUser methods).
 *
 */
export default class URLStrategy extends strategy.Strategy {
  constructor(options) {
    super();
    options = options || {}; // eslint-disable-line
    this.name = 'url';
    this._prefix = options.route || '/temporary/';
    this._decrypt = options.decryptUrl || crypto.decrypt;
    this._delimiter = options.delimiter || DELIMITER;
    this._roundedTo = options.timeRoundedTo || ROUNDED_TO;
    this._expiryTime = options.expiryTime || EXPIRY_TIME;
    this._logger = options.logger || noop;
  }
  toAuthUrl(req, url) {
    const time = roundedTime(this._roundedTo).getTime();
    const expires = time + this._expiryTime;
    const self = this;
    return serializeUserAsPromised(req.user, req)
      .then((user) => {
        const str = [url, user, expires].join(self._delimiter);
        return req.baseUrl + self._prefix + crypto.encrypt(str);
      });
  }
  fromAuthUrl(encurl, req, done) {
    try {
      const str = this._decrypt(encurl);
      const [url, userSerialized, expireStr] = str.split(this._delimiter);

      passport.deserializeUser(userSerialized, req, (err, user) => {
        if (err || !user) {
          done(err, user);
        } else {
          const expireTime = parseInt(expireStr, 10);
          if (Number.isNaN(expireTime)) { // eslint-disable-line
            done('Bad timestamp', null);
          }
          const expire = new Date(expireTime);
          if (expire < new Date()) {
            done(EXPIRED, null);
          }
          done(null, [url, user]);
        }
      });
    } catch (err) {
      done(EXPIRED, null);
    }
  }
  authenticate(req) {
    if (!req.url.startsWith(this._prefix)) {
      return this.fail();
    }
    const self = this;
    function redirect(url, user) {
      req.url = `/${urlRelative(req.baseUrl, url)}`;
      self._logger(`Redirecting authenticated URL to ${req.url}`);
      self.success(user);
    }
    this.fromAuthUrl(req.path.slice(this._prefix.length), req, (err, user) => {
      if (err) {
        if (err === EXPIRED) {
          // This is really a 401, but that causes a login popup in the browser
          // and this is really bad, since these authentication URLs don't work
          // if the user authenticates using basic authentication.
          self.fail(404);
        } else {
          self.error(err);
        }
      }
      if (!user) {
        self.fail(400);
      } else {
        redirect(...user);
      }
    });
    return undefined;
  }
}
